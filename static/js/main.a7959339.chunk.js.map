{"version":3,"sources":["nft.ts","Web3States.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["window","addEventListener","event","data","ports","console","log","dartCommunicationPort","onmessage","getConnector","sendMessage","a","walletConnect","mapEthereumWallet","WalletConnectConnectionProvider","bridge","clientMeta","description","url","icons","name","rpc","chainId","qrcode","qrcodeModal","open","uri","cb","opts","JSON","stringify","type","message","close","signingMethods","Connector","create","connectWallet","connector","connection","subscribe","con","status","address","connect","mintAndSell","ipfsUri","price","royalty","collection","sdk","createRaribleSdk","wallet","nft","generateTokenId","toContractAddress","minter","toUnionAddress","tokenId","getIPFS","mintRequest","collectionId","mint","mintResponse","parseFloat","submit","supply","lazyMint","creators","account","value","royalties","mintSubmitResponse","order","sell","itemId","prepareSellResponse","amount","currency","link","getOptions","option","obj","image","external_url","attributes","form","FormData","append","Blob","axios","method","headers","pinata_api_key","pinata_secret_api_key","response","IpfsHash","disconnectWallet","localStorage","setItem","onerror","errorMsg","lineNumber","stringParam","postMessage","defaultSendMessage","Web3States","props","timerID","state","web3","ethereum","web3Provider","currentProvider","setInterval","tick","this","clearInterval","setState","React","Component","App","className","onClick","href","target","rel","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","createRoot","document","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.a7959339.chunk.js","sourcesContent":["import {Connector} from \"@rarible/connector\";\nimport {WalletConnectConnectionProvider} from \"@rarible/connector-walletconnect\";\nimport {mapEthereumWallet} from '@rarible/connector-helper';\nimport {createRaribleSdk} from '@rarible/sdk';\nimport {toContractAddress} from \"@rarible/types\";\nimport {toUnionAddress} from \"@rarible/types/build/union-address\";\nimport {PrepareMintRequest} from \"@rarible/sdk/build/types/nft/mint/prepare-mint-request.type\";\n\nimport axios from \"axios\";\n\n// listen for messages from dart\nwindow.addEventListener('message', function (event) {\n    if (event.data === 'capturePort') {\n        if (event.ports[0] != null) {\n            console.log('Port set');\n            // @ts-ignore\n            window.dartCommunicationPort = event.ports[0];\n            // @ts-ignore\n            window.dartCommunicationPort.onmessage = function (event) {\n                console.log(`Message from dart side ${event.data}`);\n            };\n        }\n    }\n}, false);\n\nconst defaultSendMessage = (stringParam: string) => {\n    // @ts-ignore\n    window?.dartCommunicationPort?.postMessage(stringParam);\n};\n\nconst getConnector = async (sendMessage: Function) => {\n    const walletConnect = mapEthereumWallet(new WalletConnectConnectionProvider({\n\n        bridge: \"https://bridge.walletconnect.org\",\n        clientMeta: {\n            description: \"WalletConnect NodeJS Client\",\n            url: \"https://nodejs.org/en/\",\n            icons: [\"https://nodejs.org/static/images/logo.svg\"],\n            name: \"WalletConnect\",\n        },\n        rpc: {\n            1: \"https://node-mainnet.rarible.com\",\n            // 1: \"https://mainnet-nethermind.blockscout.com/\",\n            3: \"https://node-ropsten.rarible.com\",\n            4: \"https://node-rinkeby.rarible.com\",\n            137: \"https://matic-mainnet.chainstacklabs.com\",\n        },\n        chainId: 1,\n        qrcode: true,\n        // qrcodeModal:QRCodeModal,\n        qrcodeModal: {\n            async open(uri: string, cb: any, opts?: any) {\n                sendMessage(JSON.stringify({type: 'LAUNCH', message: uri}))\n                console.log(uri)\n            },\n            async close() {\n                console.log('closed method was called ')\n                return 'darova'\n            }\n        },\n        // qrcodeModalOptions: {mobileLinks: [\"metamask\", \"trust\"]},\n        signingMethods: [\n            'eth_signTypedData_v4',\n\n            'eth_sendTransaction',\n            'eth_signTransaction',\n            'eth_sign',\n            'eth_signTypedData',\n\n            'eth_signTypedData_v1',\n            'eth_signTypedData_v2',\n            'eth_signTypedData_v3',\n            'eth_signTypedData_v4',\n            'personal_sign',\n        ],\n    }))\n\n    return Connector.create(walletConnect);\n};\n\nconst connectWallet = async (sendMessage: Function = () => {\n    console.log('connectWallet default console log')\n}) => {\n    const connector = await getConnector(sendMessage);\n    connector.connection.subscribe(async (con) => {\n            console.log(\"connection: \" + con.status);\n            if (con.status === \"connected\") {\n                sendMessage(JSON.stringify({\n                    type: 'CONNECTED', message: {\n                        address: con.connection.address,\n                    }\n                }))\n            }\n        }\n    )\n\n    await connect(connector)\n};\n\nconst disconnectWallet = (sendMessage: Function) => {\n    localStorage.setItem('walletconnect', '');\n    sendMessage(JSON.stringify({type: 'DISCONNECTED', message: null}))\n};\n\n\nconst mintAndSell = async (\n    ipfsUri: string = '',\n    name: string = 'Default name',\n    description: string = 'Default description',\n    price: string = '1',\n    royalty: string = '0',\n    sendMessage: Function = () => {\n        console.log('mintAndSell default console log')\n    },\n) => {\n    const connector = await getConnector(sendMessage);\n\n    connector.connection.subscribe(async (con) => {\n            try {\n                console.log(\"connection: \" + con.status);\n                if (con.status === \"connected\") {\n                    console.log('mint and sell logic started')\n                    // prod\n                    const collection = 'ETHEREUM:0xc9154424B823b10579895cCBE442d41b9Abd96Ed';\n                    // staging\n                    // const collection = 'ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82';\n                    // dev\n                    // const collection = 'ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05';\n                    // @ts-ignore\n                    const sdk = createRaribleSdk(con.connection.wallet, \"prod\");\n                    const tokenId = await sdk.nft.generateTokenId({\n                        collection: toContractAddress(collection),\n                        minter: toUnionAddress(`ETHEREUM:${con.connection.address}`),\n                    })\n                    console.log(tokenId);\n\n\n                    let uri;\n                    try {\n                        uri = await getIPFS(ipfsUri, tokenId?.tokenId, name, description);\n                    } catch (err) {\n                        sendMessage(JSON.stringify({\n                            type: 'LOAD_TO_IPFS_ERROR',\n                            message: JSON.stringify(err),\n                        }))\n                        throw err;\n                    }\n\n\n                    let mintSubmitResponse;\n                    try {\n                        const mintRequest: PrepareMintRequest = {\n                            // @ts-ignore\n                            collectionId: toContractAddress(collection),\n                            tokenId,\n                        };\n                        const mintResponse = await sdk.nft.mint(mintRequest);\n                        sendMessage(JSON.stringify({type: 'LOADED_TO_IPFS', message: null}))\n                        sendMessage(JSON.stringify({type: 'LAUNCH', message: null}))\n                        console.log('ipfs url ' + uri);\n                        console.log(`the price is ${parseFloat(price)}`);\n                        console.log(`the royalties is ${parseFloat(royalty)}`);\n\n                        mintSubmitResponse = await mintResponse.submit({\n                            uri,\n                            supply: 1,\n                            lazyMint: true,\n                            creators: [\n                                {\n                                    account: toUnionAddress(`ETHEREUM:${con.connection.address}`),\n                                    value: 10000,\n                                },\n                            ],\n                            royalties: [{\n                                account: toUnionAddress(`ETHEREUM:${con.connection.address}`),\n                                value: parseFloat(royalty) * 100 || 0,\n                            }],\n                        });\n                    } catch (e) {\n                        sendMessage(JSON.stringify({\n                            type: 'MINT_ERROR',\n                            message: JSON.stringify(e),\n                        }))\n                        throw e;\n                    }\n\n\n                    try {\n                        sendMessage(JSON.stringify({type: 'LAUNCH', message: null}))\n                        const prepareSellResponse = await sdk.order.sell({itemId: mintSubmitResponse.itemId});\n                        await prepareSellResponse.submit({\n                            amount: 1,\n                            price: parseFloat(price),\n                            currency: {\n                                \"@type\": \"ETH\",\n                            },\n                        });\n                        console.log('EVERYTHING COMPLETED');\n                        sendMessage(JSON.stringify({\n                            type: 'MINTED_AND_PUT_ON_SALE',\n                            message: {\n                                link: `https://rarible.com/token/0xc9154424B823b10579895cCBE442d41b9Abd96Ed:${tokenId?.tokenId}`,\n                            },\n                        }))\n                    } catch (e) {\n                        sendMessage(JSON.stringify({\n                            type: 'SELL_ERROR',\n                            message: JSON.stringify(e),\n                        }))\n                        throw e;\n                    }\n                }\n            } catch (e: any) {\n                console.log(e);\n                sendMessage(JSON.stringify({\n                    type: 'ERROR',\n                    message: JSON.stringify(e.message),\n                }))\n            }\n        }\n    );\n\n    await connect(connector)\n\n};\n\nconst connect = async (connector: any) => {\n    const option = (await connector.getOptions())[0];\n    console.log(option);\n    await connector.connect(option);\n};\n\n\nconst getIPFS = async (ipfsUri: string, tokenId: any, name: string, description: string) => {\n    const obj = {\n        name: name,\n        description: description,\n        image: ipfsUri,\n        external_url: `https://rarible.com/token/0xc9154424B823b10579895cCBE442d41b9Abd96Ed:${tokenId}`,\n        attributes: []\n    };\n\n    const form = new FormData();\n\n    const fileName = 'test.json';\n\n    form.append('file', new Blob([JSON.stringify(obj)], {type: 'text/json'}), fileName);\n\n\n    // rarible pinata\n    // const response = await axios({\n    //     method: \"post\",\n    //     url: \"https://pinata.rarible.com/upload\",\n    //     data: form,\n    //     headers: {\n    //         \"Content-Type\": \"multipart/form-data\",\n    //     },\n    // });\n\n    // custom pinata\n    const response = await axios({\n        method: \"post\",\n        url: \"https://api.pinata.cloud/pinning/pinFileToIPFS\",\n        data: form,\n        headers: {\n            \"Content-Type\": \"multipart/form-data\",\n            pinata_api_key: '54847e2d543b337f65a6',\n            pinata_secret_api_key: '47c8bc5bf00cb106e2173ef8b51c44e54d01307a3cf5ff28efa8692484d4ffb8',\n        },\n    });\n    console.log('ended json upload to ipfs ')\n\n    return `ipfs://ipfs/${response.data.IpfsHash}`\n\n}\n\n// @ts-ignore\nwindow.mintAndSell = mintAndSell;\n// @ts-ignore\nwindow.connectWallet = connectWallet;\n// @ts-ignore\nwindow.disconnectWallet = disconnectWallet;\n\nwindow.onerror = function myErrorHandler(errorMsg, url, lineNumber) {\n    console.log(errorMsg, url, lineNumber);\n    defaultSendMessage(JSON.stringify({\n        type: 'ERROR',\n        message: JSON.stringify(errorMsg),\n    }))\n    return false;\n}\n\nexport default {\n    mintAndSell,\n};\n","import React from \"react\";\n\nexport class Web3States extends React.Component<{}, {\n    web3: any,\n    ethereum: any,\n    web3Provider: any,\n}> {\n    private timerID: NodeJS.Timer;\n\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            // @ts-ignore\n            web3: window.web3,\n            // @ts-ignore\n            ethereum: window.ethereum,\n            // @ts-ignore\n            web3Provider: window.web3?.currentProvider,\n        };\n        this.timerID = setInterval(\n            () => this.tick(),\n            1000\n        );\n    }\n\n    componentDidMount() {\n        this.timerID = setInterval(\n            () => this.tick(),\n            1000\n        );\n    }\n\n    componentWillUnmount() {\n        clearInterval(this.timerID);\n    }\n\n    tick() {\n        this.setState({\n            // @ts-ignore\n            web3: window.web3,\n            // @ts-ignore\n            ethereum: window.ethereum,\n            // @ts-ignore\n            web3Provider: window.web3?.currentProvider,\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                <h3>Web3 exists: {!!this.state.web3 ? 'true' : 'false'}</h3>\n                <h3>Ethereum exists: {!!this.state.ethereum ? 'true' : 'false'}</h3>\n                <h3>Web3 provider exists : {!!this.state.web3Provider ? 'true' : 'false'}</h3>\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport './App.css';\nimport nft from \"./nft\";\nimport {Web3States} from \"./Web3States\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <p>\n          Edit <code>src/App.tsx</code> and save to reload.\n        </p>\n        <Web3States/>\n        <button onClick={() => nft.mintAndSell()}> rarible</button>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Learn React\n        </a>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}